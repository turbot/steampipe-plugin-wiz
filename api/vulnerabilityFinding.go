package api

import (
	"context"

	"github.com/machinebox/graphql"
)

// Define the query
const (
	queryVulnerabilityFindingList = `
query ListVulnerabilityFindings($first: Int, $after: String, $filter: VulnerabilityFindingFilters, $orderBy: VulnerabilityFindingOrder) {
  vulnerabilityFindings(first: $first, after: $after, filterBy: $filter, orderBy: $orderBy) {
    pageInfo {
      hasNextPage
      endCursor
    }
    totalCount
    nodes {
      name
      detailedName
      severity: vendorSeverity
      fixedVersion
      detectionMethod
      hasExploit
      CVEDescription
      CVSSSeverity
      description
      exploitabilityScore
      firstDetectedAt
      hasCisaKevExploit
      id
      impactScore
      lastDetectedAt
      link
      locationPath
      portalUrl
      remediation
      resolutionReason
      resolvedAt
      score
      status
      version
      vulnerabilityExternalId
      vulnerableAsset {
        ... on VulnerableAssetBase {
          id
          type
          name
          cloudPlatform
          subscriptionId
          tags
        }
        ... on VulnerableAssetVirtualMachine {
          id
          type
          name
          cloudPlatform
          subscriptionId
          tags
          operatingSystem
        }
        ... on VulnerableAssetServerless {
          id
          type
          name
          cloudPlatform
          subscriptionId
          tags
        }
        ... on VulnerableAssetContainerImage {
          id
          type
          name
          cloudPlatform
          subscriptionId
          tags
        }
        ... on VulnerableAssetContainer {
          id
          type
          name
          cloudPlatform
          subscriptionId
          tags
        }
      }
    }
  }
}
`

	queryVulnerabilityFindingGet = `
query GetVulnerabilityFinding($id: ID!) {
  vulnerabilityFinding(id: $id) {
    name
    detailedName
    severity: vendorSeverity
    fixedVersion
    detectionMethod
    hasExploit
    CVEDescription
    CVSSSeverity
    description
    exploitabilityScore
    firstDetectedAt
    hasCisaKevExploit
    id
    impactScore
    lastDetectedAt
    link
    locationPath
    portalUrl
    remediation
    resolutionReason
    resolvedAt
    score
    status
    version
    vulnerabilityExternalId
    vulnerableAsset {
      ... on VulnerableAssetBase {
        id
        type
        name
        cloudPlatform
        subscriptionId
        tags
      }
      ... on VulnerableAssetVirtualMachine {
        id
        type
        name
        cloudPlatform
        subscriptionId
        tags
        operatingSystem
      }
      ... on VulnerableAssetServerless {
        id
        type
        name
        cloudPlatform
        subscriptionId
        tags
      }
      ... on VulnerableAssetContainerImage {
        id
        type
        name
        cloudPlatform
        subscriptionId
        tags
      }
      ... on VulnerableAssetContainer {
        id
        type
        name
        cloudPlatform
        subscriptionId
        tags
      }
    }
  }
}
`
)

// Vulnerability asset object
type VulnerableAsset struct {
	CloudPlatform   string      `json:"cloudPlatform,omitempty"`
	Id              string      `json:"id,omitempty"`
	Name            string      `json:"name,omitempty"`
	OperatingSystem string      `json:"operatingSystem,omitempty"`
	SubscriptionId  string      `json:"subscriptionId,omitempty"`
	Tags            interface{} `json:"tags,omitempty"`
	Type            string      `json:"type,omitempty"`
}

// Vulnerability finding object
type VulnerabilityFinding struct {
	CVEDescription          string          `json:"CVEDescription"`
	CVSSSeverity            string          `json:"CVSSSeverity"`
	Description             string          `json:"description"`
	DetailedName            string          `json:"detailedName"`
	DetectionMethod         string          `json:"detectionMethod"`
	ExploitabilityScore     float64         `json:"exploitabilityScore"`
	FirstDetectedAt         string          `json:"firstDetectedAt"`
	FixedVersion            string          `json:"fixedVersion"`
	HasCisaKevExploit       bool            `json:"hasCisaKevExploit"`
	HasExploit              bool            `json:"hasExploit"`
	Id                      string          `json:"id"`
	ImpactScore             float64         `json:"impactScore"`
	LastDetectedAt          string          `json:"lastDetectedAt"`
	Link                    string          `json:"link"`
	LocationPath            string          `json:"locationPath"`
	Name                    string          `json:"name"`
	PortalUrl               string          `json:"portalUrl"`
	Remediation             string          `json:"remediation"`
	ResolutionReason        string          `json:"resolutionReason"`
	ResolvedAt              string          `json:"resolvedAt"`
	Score                   float64         `json:"score"`
	Severity                string          `json:"severity"`
	Status                  string          `json:"status"`
	Version                 string          `json:"version"`
	VulnerabilityExternalId string          `json:"vulnerabilityExternalId"`
	VulnerableAsset         VulnerableAsset `json:"vulnerableAsset"`
}

// Relay-style node for the vulnerability finding
type VulnerabilityFindingConnection struct {
	Nodes      []VulnerabilityFinding `json:"nodes"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

// ListVulnerabilityFindingsResponse is returned by ListVulnerabilityFindings on success
type ListVulnerabilityFindingsResponse struct {
	VulnerabilityFindings VulnerabilityFindingConnection `json:"vulnerabilityFindings"`
}

// Fields used to filter the vulnerability finding response
type ListVulnerabilityFindingsRequestConfiguration struct {
	// Optional - return only vulnerability findings found via the specified detection method.
	//
	// Possible values are: PACKAGE, DEFAULT_PACKAGE, LIBRARY, CONFIG_FILE, OPEN_PORT, STARTUP_SERVICE, CONFIGURATION, CLONED_REPOSITORY, OS, ARTIFACTS_ON_DISK, WINDOWS_REGISTRY, INSTALLED_PROGRAM, WINDOWS_SERVICE, INSTALLED_PROGRAM_BY_SERVICE, FILE_PATH, UNKNOWN.
	DetectionMethod string

	// Optional - return only vulnerability findings for vulnerabilities with an available fix.
	HasFix *bool

	// When paginating forwards, the cursor to continue.
	EndCursor string

	// Optional - return only vulnerability findings for vulnerabilities with an available CISA KEV exploit.
	HasCisaKevExploit *bool

	// Optional - return only vulnerability findings for vulnerabilities with an available exploit.
	HasExploit *bool

	// The maximum number of results to return in a single call. To retrieve the
	// remaining results, make another call with the returned EndCursor value.
	//
	// Maximum limit is 5000.
	Limit int

	// Optional - filter by vulnerability vendor severity.
	//
	// Possible values are: NONE, LOW, MEDIUM, HIGH, CRITICAL.
	VendorSeverity string

	// Optional - filter by finding status.
	//
	// Possible values are: UNRESOLVED, RESOLVED, PASSED, IGNORED.
	Status string

	// Optional - return only vulnerability findings whose external ID matches.
	VulnerabilityExternalId string
}

// ListVulnerabilityFindings returns a paginated list of the vulnerabilities detected on the cloud resources
//
// @param ctx context for configuration
//
// @param client the API client
//
// @param options the API parameters
func ListVulnerabilityFindings(
	ctx context.Context,
	client *Client,
	options *ListVulnerabilityFindingsRequestConfiguration,
) (*ListVulnerabilityFindingsResponse, error) {
	// Make a request
	req := graphql.NewRequest(queryVulnerabilityFindingList)

	// Check for optional filters
	filter := map[string]interface{}{}
	if options.DetectionMethod != "" {
		filter["detectionMethod"] = options.DetectionMethod
	}
	if options.HasCisaKevExploit != nil {
		filter["hasCisaKevExploit"] = options.HasCisaKevExploit
	}
	if options.HasExploit != nil {
		filter["hasExploit"] = options.HasExploit
	}
	if options.HasFix != nil {
		filter["hasFix"] = options.HasFix
	}
	if options.VendorSeverity != "" {
		filter["vendorSeverity"] = options.VendorSeverity
	}
	if options.Status != "" {
		filter["status"] = options.Status
	}
	if options.VulnerabilityExternalId != "" {
		filter["vulnerabilityExternalId"] = options.VulnerabilityExternalId
	}
	req.Var("filter", filter)

	// Check for paging options and set it
	if options.Limit > 0 {
		req.Var("first", options.Limit)
	}
	if options.EndCursor != "" {
		req.Var("after", options.EndCursor)
	}

	// execute api call
	var responseData ListVulnerabilityFindingsResponse
	err := client.doRequest(req, &responseData)
	if err != nil {
		return nil, err
	}

	return &responseData, err
}

// GetVulnerabilityFindingResponse is returned by GetVulnerabilityFinding on success
type GetVulnerabilityFindingResponse struct {
	VulnerabilityFinding VulnerabilityFinding `json:"vulnerabilityFinding"`
}

// GetVulnerabilityFinding returns a specific vulnerability finding that matches the ID
//
// @param ctx context for configuration
//
// @param client the API client
//
// @param id unique identifier of the resource
func GetVulnerabilityFinding(
	ctx context.Context,
	client *Client,
	id string,
) (*GetVulnerabilityFindingResponse, error) {
	// Make a request
	req := graphql.NewRequest(queryVulnerabilityFindingGet)

	// Set the required variables
	req.Var("id", id)

	// execute api call
	var responseData GetVulnerabilityFindingResponse
	err := client.doRequest(req, &responseData)
	if err != nil {
		return nil, err
	}

	return &responseData, err
}
