package wiz

import (
	"context"

	"github.com/turbot/steampipe-plugin-sdk/v5/grpc/proto"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin/transform"
	"github.com/turbot/steampipe-plugin-wiz/api"

	"github.com/turbot/go-kit/types"
)

//// TABLE DEFINITION

func tableWizVulnerabilityFinding(ctx context.Context) *plugin.Table {
	return &plugin.Table{
		Name:        "wiz_vulnerability_finding",
		Description: "Wiz Vulnerability Finding",
		List: &plugin.ListConfig{
			Hydrate: listWizVulnerabilityFindings,
			KeyColumns: plugin.KeyColumnSlice{
				{Name: "detection_method", Require: plugin.Optional},
				{Name: "fixed_version", Require: plugin.Optional},
				{Name: "has_cisa_kev_exploit", Require: plugin.Optional, Operators: []string{"<>", "="}},
				{Name: "has_exploit", Require: plugin.Optional, Operators: []string{"<>", "="}},
				{Name: "severity", Require: plugin.Optional},
				{Name: "status", Require: plugin.Optional},
				{Name: "vulnerability_external_id", Require: plugin.Optional},
			},
		},
		Get: &plugin.GetConfig{
			Hydrate:    getVulnerabilityFinding,
			KeyColumns: plugin.SingleColumn("id"),
		},
		Columns: []*plugin.Column{
			{Name: "name", Type: proto.ColumnType_STRING, Description: "The name of the vulnerability."},
			{Name: "id", Type: proto.ColumnType_STRING, Description: "The wiz identifier for the vulnerability."},
			{Name: "detailed_name", Type: proto.ColumnType_STRING, Description: "The library/package name where the vulnerability was detected."},
			{Name: "severity", Type: proto.ColumnType_STRING, Description: "The calculated CVSS 3.x severity from the vendor. Possible values are: NONE, LOW, MEDIUM, HIGH, CRITICAL."},
			{Name: "fixed_version", Type: proto.ColumnType_STRING, Description: "The initial version of the library/package where the vulnerability was fixed."},
			{Name: "detection_method", Type: proto.ColumnType_STRING, Description: "The detection method for this vulnerability finding. Possible values are: PACKAGE, DEFAULT_PACKAGE, LIBRARY, CONFIG_FILE, OPEN_PORT, STARTUP_SERVICE, CONFIGURATION, CLONED_REPOSITORY, OS, ARTIFACTS_ON_DISK, WINDOWS_REGISTRY, INSTALLED_PROGRAM, WINDOWS_SERVICE, INSTALLED_PROGRAM_BY_SERVICE, FILE_PATH, UNKNOWN."},
			{Name: "has_exploit", Type: proto.ColumnType_BOOL, Description: "True, if the vulnerability has a known public exploit."},
			{Name: "cve_description", Type: proto.ColumnType_STRING, Description: "The vulnerability description from NVD.", Transform: transform.FromField("CVEDescription")},
			{Name: "cvss_severity", Type: proto.ColumnType_STRING, Description: "The calculated CVSS 3.x severity from NVD.", Transform: transform.FromField("CVSSSeverity")},
			{Name: "description", Type: proto.ColumnType_STRING, Description: "The wiz verbose description of how the vulnerability finding was detected, with library/package, detection method, affected versions, severity and remediation suggestion."},
			{Name: "exploitability_score", Type: proto.ColumnType_DOUBLE, Description: "The CVSS 3.x exploitability score from NVD."},
			{Name: "first_detected_at", Type: proto.ColumnType_TIMESTAMP, Description: "The first time this vulnerability finding was detected on this resource."},
			{Name: "has_cisa_kev_exploit", Type: proto.ColumnType_BOOL, Description: "True, if the vulnerability has an exploit in the CISA KEV published catalog."},
			{Name: "impact_score", Type: proto.ColumnType_DOUBLE, Description: "The CVSS 3.x impact score from NVD."},
			{Name: "last_detected_at", Type: proto.ColumnType_TIMESTAMP, Description: "The last time this vulnerability finding was seen on this resource."},
			{Name: "link", Type: proto.ColumnType_STRING, Description: "The link to the vendor vulnerability advisory."},
			{Name: "location_path", Type: proto.ColumnType_STRING, Description: "The local path to the package/library/file where the vulnerability was detected."},
			{Name: "portal_url", Type: proto.ColumnType_STRING, Description: "The wiz URL for the vulnerability finding of a specific CVE on a specific resource."},
			{Name: "remediation", Type: proto.ColumnType_STRING, Description: "The suggested command/method for remediating the vulnerability finding."},
			{Name: "resolution_reason", Type: proto.ColumnType_STRING, Description: "The status resolution reason."},
			{Name: "resolved_at", Type: proto.ColumnType_TIMESTAMP, Description: "The time this vulnerability finding was resolved."},
			{Name: "score", Type: proto.ColumnType_DOUBLE, Description: "The CVSS 3.x score from NVD."},
			{Name: "status", Type: proto.ColumnType_STRING, Description: "The resolution status of the finding. Possible values are: UNRESOLVED, RESOLVED, PASSED, IGNORED."},
			{Name: "version", Type: proto.ColumnType_STRING, Description: "The version of the library/package where the vulnerability was detected."},
			{Name: "vulnerability_external_id", Type: proto.ColumnType_STRING, Description: "The vulnerability identifier."},
			{Name: "vulnerable_asset", Type: proto.ColumnType_JSON, Description: "The details of the asset where the vulnerability was detected."},
		},
	}
}

//// LIST FUNCTION

func listWizVulnerabilityFindings(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	// Create client
	conn, err := getClient(ctx, d)
	if err != nil {
		plugin.Logger(ctx).Error("wiz_vulnerability_finding.listWizVulnerabilityFindings", "connection_error", err)
		return nil, err
	}

	options := &api.ListVulnerabilityFindingsRequestConfiguration{}

	// Default set to 5000.
	// This is the maximum number of items can be requested.
	pageLimit := 5000

	// Adjust page limit, if less than default value
	limit := d.QueryContext.Limit
	if limit != nil && int(*limit) < pageLimit {
		pageLimit = int(*limit)
	}
	options.Limit = pageLimit

	// Check for additional filters
	if d.EqualsQualString("detection_method") != "" {
		options.DetectionMethod = d.EqualsQualString("detection_method")
	}
	if d.EqualsQuals["has_cisa_kev_exploit"] != nil {
		options.HasCisaKevExploit = types.Bool(d.EqualsQuals["has_cisa_kev_exploit"].GetBoolValue())
	}
	if d.EqualsQuals["has_exploit"] != nil {
		options.HasExploit = types.Bool(d.EqualsQuals["has_exploit"].GetBoolValue())
	}
	if d.EqualsQualString("severity") != "" {
		options.VendorSeverity = d.EqualsQualString("severity")
	}
	if d.EqualsQualString("status") != "" {
		options.Status = d.EqualsQualString("status")
	}
	if d.EqualsQualString("vulnerability_external_id") != "" {
		options.VulnerabilityExternalId = d.EqualsQualString("vulnerability_external_id")
	}

	// Check for not equal qual
	filterQuals := []string{"has_cisa_kev_exploit", "has_exploit"}
	for _, qual := range filterQuals {
		if d.Quals[qual] != nil {
			for _, q := range d.Quals[qual].Quals {
				value := q.Value.GetBoolValue()
				if q.Operator == "<>" {
					switch qual {
					case "has_cisa_kev_exploit":
						options.HasCisaKevExploit = types.Bool(!value)
					case "has_exploit":
						options.HasExploit = types.Bool(!value)
					}
					break
				}
			}
		}
	}

	// Since the result dataset can be large
	// The below filters will reduce the number of data returned based on the partial match,
	// which will reduce the query time.
	if d.QueryContext.UnsafeQuals != nil {
		if d.QueryContext.UnsafeQuals["fixed_version"] != nil {
			if d.EqualsQualString("fixed_version") != "" {
				options.HasFix = types.Bool(true)
			}
		}
	}

	for {
		query, err := api.ListVulnerabilityFindings(context.Background(), conn, options)
		if err != nil {
			plugin.Logger(ctx).Error("wiz_vulnerability_finding.listWizVulnerabilityFindings", "query_error", err)
			return nil, err
		}

		for _, finding := range query.VulnerabilityFindings.Nodes {
			d.StreamListItem(ctx, finding)

			// Context can be cancelled due to manual cancellation or the limit has been hit
			if d.RowsRemaining(ctx) == 0 {
				return nil, nil
			}
		}

		// Return if all resources are processed
		if !query.VulnerabilityFindings.PageInfo.HasNextPage {
			break
		}

		// Else set the next page cursor
		options.EndCursor = query.VulnerabilityFindings.PageInfo.EndCursor
	}

	return nil, nil
}

//// HYDRATE FUNCTIONS

func getVulnerabilityFinding(ctx context.Context, d *plugin.QueryData, h *plugin.HydrateData) (interface{}, error) {
	// Check the quals
	id := d.EqualsQualString("id")

	// Return nil, if empty
	if id == "" {
		return nil, nil
	}

	// Create client
	conn, err := getClient(ctx, d)
	if err != nil {
		plugin.Logger(ctx).Error("wiz_vulnerability_finding.getVulnerabilityFinding", "connection_error", err)
		return nil, err
	}

	query, err := api.GetVulnerabilityFinding(context.Background(), conn, id)
	if err != nil {
		plugin.Logger(ctx).Error("wiz_vulnerability_finding.getVulnerabilityFinding", "query_error", err)
		return nil, err
	}

	return query.VulnerabilityFinding, nil
}
